# AGENTS.md

## Project Overview

A productivity API built with Rust, Axum, and PostgreSQL. Features include daily tasks, habits, goals, and pomodoro session tracking. Users authenticate via JWT.

## Tech Stack

- **Language:** Rust (edition 2024)
- **Framework:** Axum 0.8
- **Database:** PostgreSQL via sqlx 0.8
- **Auth:** JWT (jsonwebtoken with rust_crypto) + Argon2 password hashing
- **Runtime:** Tokio

## Project Structure

```
src/
├── main.rs              # Entry point, router setup, app state
├── state.rs             # AppState (db pool + jwt secret)
├── models/              # DB row structs + request/response types
│   ├── user.rs
│   ├── goal.rs
│   ├── task.rs
│   ├── habit.rs
│   └── pomodoro.rs
├── auth/                # Authentication
│   ├── handlers.rs      # register, login
│   ├── jwt.rs           # create_token, decode_token
│   ├── middleware.rs    # AuthUser extractor (FromRequestParts)
│   └── router.rs        # /auth routes
├── tasks/               # Task CRUD
├── habits/              # Habit CRUD + completions
├── goals/               # Goal CRUD
└── pomodoro/            # Pomodoro session tracking
```

## Conventions

### Models

- Each resource has a `Model` struct (DB row, derives `sqlx::FromRow`)
- `CreateModel` for POST request bodies
- `UpdateModel` for PATCH request bodies (all fields `Option<T>`)
- Enums stored as `text` in Postgres, use `#[sqlx(type_name = "text", rename_all = "snake_case")]`

### Handlers

- Always return `impl IntoResponse`
- Use `(StatusCode, Json<serde_json::Value>)` for responses
- Use `json!({...})` from `serde_json` for response bodies
- Protected routes take `auth: AuthUser` as first parameter

### Auth

- JWT is passed as `Authorization: Bearer <token>` header
- `AuthUser` extractor validates the token and provides `user_id: Uuid`
- All routes except `/auth/register` and `/auth/login` require auth

### Database

- Use `sqlx::query_as::<_, Model>(...)` for queries that return rows
- Use `sqlx::query!(...)` for mutations with no return
- Always use `RETURNING *` after INSERT/UPDATE to get the row back
- All IDs are UUIDs generated by Postgres via `gen_random_uuid()`
- Access the pool via `state.db_pool`

### Error Handling

- DB errors → `StatusCode::INTERNAL_SERVER_ERROR`
- Not found → `StatusCode::NOT_FOUND`
- Conflict (duplicate) → `StatusCode::CONFLICT`
- Auth errors → `StatusCode::UNAUTHORIZED`
- Always filter queries by `user_id` to prevent users accessing each other's data

### Routing

- Each module has its own `router.rs` with a `module_router()` function returning `Router<AppState>`
- Routers are nested in `main.rs` under their respective prefixes

## Environment Variables

```env
DATABASE_URL=postgres://user:password@localhost/projekt
JWT_SECRET=your_long_random_secret
```

## Database Migrations

Run with:

```bash
sqlx migrate run
```

Migration files live in `migrations/`. Always use `TIMESTAMPTZ` for timestamps and `UUID` for IDs.

## Running the Project

```bash
cargo run
```

Server starts on `http://127.0.0.1:3000`
